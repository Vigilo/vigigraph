//MooTools More, <http://mootools.net/more>. Copyright (c) 2006-2009 Aaron Newton <http://clientcide.com/>, Valerio Proietti <http://mad4milk.net> & the MooTools team <http://mootools.net/developers>, MIT Style License.

/*
---

script: More.js

description: MooTools More

license: MIT-style license

authors:
- Guillermo Rauch
- Thomas Aylott
- Scott Kyle

requires:
- core:1.2.4/MooTools

provides: [MooTools.More]

...
*/

MooTools.More = {
    'version': '1.2.4.2',
    'build': 'bd5a93c0913cce25917c48cbdacde568e15e02ef'
};

/*
---

script: MooTools.Lang.js

description: Provides methods for localization.

license: MIT-style license

authors:
- Aaron Newton

requires:
- core:1.2.4/Events
- /MooTools.More

provides: [MooTools.Lang]

...
*/

(function(){

    var data = {
        language: 'en-US',
        languages: {
            'en-US': {}
        },
        cascades: ['en-US']
    };
    
    var cascaded;

    MooTools.lang = new Events();

    $extend(MooTools.lang, {

        setLanguage: function(lang){
            if (!data.languages[lang]) return this;
            data.language = lang;
            this.load();
            this.fireEvent('langChange', lang);
            return this;
        },

        load: function() {
            var langs = this.cascade(this.getCurrentLanguage());
            cascaded = {};
            $each(langs, function(set, setName){
                cascaded[setName] = this.lambda(set);
            }, this);
        },

        getCurrentLanguage: function(){
            return data.language;
        },

        addLanguage: function(lang){
            data.languages[lang] = data.languages[lang] || {};
            return this;
        },

        cascade: function(lang){
            var cascades = (data.languages[lang] || {}).cascades || [];
            cascades.combine(data.cascades);
            cascades.erase(lang).push(lang);
            var langs = cascades.map(function(lng){
                return data.languages[lng];
            }, this);
            return $merge.apply(this, langs);
        },

        lambda: function(set) {
            (set || {}).get = function(key, args){
                return $lambda(set[key]).apply(this, $splat(args));
            };
            return set;
        },

        get: function(set, key, args){
            if (cascaded && cascaded[set]) return (key ? cascaded[set].get(key, args) : cascaded[set]);
        },

        set: function(lang, set, members){
            this.addLanguage(lang);
            langData = data.languages[lang];
            if (!langData[set]) langData[set] = {};
            $extend(langData[set], members);
            if (lang == this.getCurrentLanguage()){
                this.load();
                this.fireEvent('langChange', lang);
            }
            return this;
        },

        list: function(){
            return Hash.getKeys(data.languages);
        }

    });

})();

/*
---

script: Log.js

description: Provides basic logging functionality for plugins to implement.

license: MIT-style license

authors:
- Guillermo Rauch
- Thomas Aylott
- Scott Kyle

requires:
- core:1.2.4/Class
- /MooTools.More

provides: [Log]

...
*/

(function(){

var global = this;

var log = function(){
    if (global.console && console.log){
        try {
            console.log.apply(console, arguments);
        } catch(e) {
            console.log(Array.slice(arguments));
        }
    } else {
        Log.logged.push(arguments);
    }
    return this;
};

var disabled = function(){
    this.logged.push(arguments);
    return this;
};

this.Log = new Class({
    
    logged: [],
    
    log: disabled,
    
    resetLog: function(){
        this.logged.empty();
        return this;
    },

    enableLog: function(){
        this.log = log;
        this.logged.each(function(args){
            this.log.apply(this, args);
        }, this);
        return this.resetLog();
    },

    disableLog: function(){
        this.log = disabled;
        return this;
    }
    
});

Log.extend(new Log).enableLog();

// legacy
Log.logger = function(){
    return this.log.apply(this, arguments);
};

})();

/*
---

script: Class.Refactor.js

description: Extends a class onto itself with new property, preserving any items attached to the class's namespace.

license: MIT-style license

authors:
- Aaron Newton

requires:
- core:1.2.4/Class
- /MooTools.More

provides: [Class.refactor]

...
*/

Class.refactor = function(original, refactors){

    $each(refactors, function(item, name){
        var origin = original.prototype[name];
        if (origin && (origin = origin._origin) && typeof item == 'function') original.implement(name, function(){
            var old = this.previous;
            this.previous = origin;
            var value = item.apply(this, arguments);
            this.previous = old;
            return value;
        }); else original.implement(name, item);
    });

    return original;

};

/*
---

script: Class.Binds.js

description: Automagically binds specified methods in a class to the instance of the class.

license: MIT-style license

authors:
- Aaron Newton

requires:
- core:1.2.4/Class
- /MooTools.More

provides: [Class.Binds]

...
*/

Class.Mutators.Binds = function(binds){
    return binds;
};

Class.Mutators.initialize = function(initialize){
    return function(){
        $splat(this.Binds).each(function(name){
            var original = this[name];
            if (original) this[name] = original.bind(this);
        }, this);
        return initialize.apply(this, arguments);
    };
};


/*
---

script: Class.Occlude.js

description: Prevents a class from being applied to a DOM element twice.

license: MIT-style license.

authors:
- Aaron Newton

requires: 
- core/1.2.4/Class
- core:1.2.4/Element
- /MooTools.More

provides: [Class.Occlude]

...
*/

Class.Occlude = new Class({

    occlude: function(property, element){
        element = document.id(element || this.element);
        var instance = element.retrieve(property || this.property);
        if (instance && !$defined(this.occluded))
            return this.occluded = instance;

        this.occluded = false;
        element.store(property || this.property, this);
        return this.occluded;
    }

});

/*
---

script: Chain.Wait.js

description: value, Adds a method to inject pauses between chained events.

license: MIT-style license.

authors:
- Aaron Newton

requires: 
- core:1.2.4/Chain 
- core:1.2.4/Element
- core:1.2.4/Fx
- /MooTools.More

provides: [Chain.Wait]

...
*/

(function(){

    var wait = {
        wait: function(duration){
            return this.chain(function(){
                this.callChain.delay($pick(duration, 500), this);
            }.bind(this));
        }
    };

    Chain.implement(wait);

    if (window.Fx){
        Fx.implement(wait);
        ['Css', 'Tween', 'Elements'].each(function(cls){
            if (Fx[cls]) Fx[cls].implement(wait);
        });
    }

    Element.implement({
        chains: function(effects){
            $splat($pick(effects, ['tween', 'morph', 'reveal'])).each(function(effect){
                effect = this.get(effect);
                if (!effect) return;
                effect.setOptions({
                    link:'chain'
                });
            }, this);
            return this;
        },
        pauseFx: function(duration, effect){
            this.chains(effect).get($pick(effect, 'tween')).wait(duration);
            return this;
        }
    });

})();

/*
---

script: Date.js

description: Extends the Date native object to include methods useful in managing dates.

license: MIT-style license

authors:
- Aaron Newton
- Nicholas Barthelemy - https://svn.nbarthelemy.com/date-js/
- Harald Kirshner - mail [at] digitarald.de; http://digitarald.de
- Scott Kyle - scott [at] appden.com; http://appden.com

requires:
- core:1.2.4/Array
- core:1.2.4/String
- core:1.2.4/Number
- core:1.2.4/Lang
- core:1.2.4/Date.English.US
- /MooTools.More

provides: [Date]

...
*/

(function(){

var Date = this.Date;

if (!Date.now) Date.now = $time;

Date.Methods = {
    ms: 'Milliseconds',
    year: 'FullYear',
    min: 'Minutes',
    mo: 'Month',
    sec: 'Seconds',
    hr: 'Hours'
};

['Date', 'Day', 'FullYear', 'Hours', 'Milliseconds', 'Minutes', 'Month', 'Seconds', 'Time', 'TimezoneOffset',
    'Week', 'Timezone', 'GMTOffset', 'DayOfYear', 'LastMonth', 'LastDayOfMonth', 'UTCDate', 'UTCDay', 'UTCFullYear',
    'AMPM', 'Ordinal', 'UTCHours', 'UTCMilliseconds', 'UTCMinutes', 'UTCMonth', 'UTCSeconds'].each(function(method){
    Date.Methods[method.toLowerCase()] = method;
});

var pad = function(what, length){
    return new Array(length - String(what).length + 1).join('0') + what;
};

Date.implement({

    set: function(prop, value){
        switch ($type(prop)){
            case 'object':
                for (var p in prop) this.set(p, prop[p]);
                break;
            case 'string':
                prop = prop.toLowerCase();
                var m = Date.Methods;
                if (m[prop]) this['set' + m[prop]](value);
        }
        return this;
    },

    get: function(prop){
        prop = prop.toLowerCase();
        var m = Date.Methods;
        if (m[prop]) return this['get' + m[prop]]();
        return null;
    },

    clone: function(){
        return new Date(this.get('time'));
    },

    increment: function(interval, times){
        interval = interval || 'day';
        times = $pick(times, 1);

        switch (interval){
            case 'year':
                return this.increment('month', times * 12);
            case 'month':
                var d = this.get('date');
                this.set('date', 1).set('mo', this.get('mo') + times);
                return this.set('date', d.min(this.get('lastdayofmonth')));
            case 'week':
                return this.increment('day', times * 7);
            case 'day':
                return this.set('date', this.get('date') + times);
        }

        if (!Date.units[interval]) throw new Error(interval + ' is not a supported interval');

        return this.set('time', this.get('time') + times * Date.units[interval]());
    },

    decrement: function(interval, times){
        return this.increment(interval, -1 * $pick(times, 1));
    },

    isLeapYear: function(){
        return Date.isLeapYear(this.get('year'));
    },

    clearTime: function(){
        return this.set({hr: 0, min: 0, sec: 0, ms: 0});
    },

    diff: function(date, resolution){
        if ($type(date) == 'string') date = Date.parse(date);
        
        return ((date - this) / Date.units[resolution || 'day'](3, 3)).toInt(); // non-leap year, 30-day month
    },

    getLastDayOfMonth: function(){
        return Date.daysInMonth(this.get('mo'), this.get('year'));
    },

    getDayOfYear: function(){
        return (Date.UTC(this.get('year'), this.get('mo'), this.get('date') + 1) 
            - Date.UTC(this.get('year'), 0, 1)) / Date.units.day();
    },

    getWeek: function(){
        return (this.get('dayofyear') / 7).ceil();
    },
    
    getOrdinal: function(day){
        return Date.getMsg('ordinal', day || this.get('date'));
    },

    getTimezone: function(){
        return this.toString()
            .replace(/^.*? ([A-Z]{3}).[0-9]{4}.*$/, '$1')
            .replace(/^.*?\(([A-Z])[a-z]+ ([A-Z])[a-z]+ ([A-Z])[a-z]+\)$/, '$1$2$3');
    },

    getGMTOffset: function(){
        var off = this.get('timezoneOffset');
        return ((off > 0) ? '-' : '+') + pad((off.abs() / 60).floor(), 2) + pad(off % 60, 2);
    },

    setAMPM: function(ampm){
        ampm = ampm.toUpperCase();
        var hr = this.get('hr');
        if (hr > 11 && ampm == 'AM') return this.decrement('hour', 12);
        else if (hr < 12 && ampm == 'PM') return this.increment('hour', 12);
        return this;
    },

    getAMPM: function(){
        return (this.get('hr') < 12) ? 'AM' : 'PM';
    },

    parse: function(str){
        this.set('time', Date.parse(str));
        return this;
    },

    isValid: function(date) {
        return !!(date || this).valueOf();
    },

    format: function(f){
        if (!this.isValid()) return 'invalid date';
        f = f || '%x %X';
        f = formats[f.toLowerCase()] || f; // replace short-hand with actual format
        var d = this;
        return f.replace(/%([a-z%])/gi,
            function($0, $1){
                switch ($1){
                    case 'a': return Date.getMsg('days')[d.get('day')].substr(0, 3);
                    case 'A': return Date.getMsg('days')[d.get('day')];
                    case 'b': return Date.getMsg('months')[d.get('month')].substr(0, 3);
                    case 'B': return Date.getMsg('months')[d.get('month')];
                    case 'c': return d.toString();
                    case 'd': return pad(d.get('date'), 2);
                    case 'H': return pad(d.get('hr'), 2);
                    case 'I': return ((d.get('hr') % 12) || 12);
                    case 'j': return pad(d.get('dayofyear'), 3);
                    case 'm': return pad((d.get('mo') + 1), 2);
                    case 'M': return pad(d.get('min'), 2);
                    case 'o': return d.get('ordinal');
                    case 'p': return Date.getMsg(d.get('ampm'));
                    case 'S': return pad(d.get('seconds'), 2);
                    case 'U': return pad(d.get('week'), 2);
                    case 'w': return d.get('day');
                    case 'x': return d.format(Date.getMsg('shortDate'));
                    case 'X': return d.format(Date.getMsg('shortTime'));
                    case 'y': return d.get('year').toString().substr(2);
                    case 'Y': return d.get('year');
                    case 'T': return d.get('GMTOffset');
                    case 'Z': return d.get('Timezone');
                }
                return $1;
            }
        );
    },

    toISOString: function(){
        return this.format('iso8601');
    }

});

Date.alias('toISOString', 'toJSON');
Date.alias('diff', 'compare');
Date.alias('format', 'strftime');

var formats = {
    db: '%Y-%m-%d %H:%M:%S',
    compact: '%Y%m%dT%H%M%S',
    iso8601: '%Y-%m-%dT%H:%M:%S%T',
    rfc822: '%a, %d %b %Y %H:%M:%S %Z',
    'short': '%d %b %H:%M',
    'long': '%B %d, %Y %H:%M'
};

var parsePatterns = [];
var nativeParse = Date.parse;

var parseWord = function(type, word, num){
    var ret = -1;
    var translated = Date.getMsg(type + 's');

    switch ($type(word)){
        case 'object':
            ret = translated[word.get(type)];
            break;
        case 'number':
            ret = translated[month - 1];
            if (!ret) throw new Error('Invalid ' + type + ' index: ' + index);
            break;
        case 'string':
            var match = translated.filter(function(name){
                return this.test(name);
            }, new RegExp('^' + word, 'i'));
            if (!match.length)    throw new Error('Invalid ' + type + ' string');
            if (match.length > 1) throw new Error('Ambiguous ' + type);
            ret = match[0];
    }

    return (num) ? translated.indexOf(ret) : ret;
};

Date.extend({

    getMsg: function(key, args) {
        return MooTools.lang.get('Date', key, args);
    },

    units: {
        ms: $lambda(1),
        second: $lambda(1000),
        minute: $lambda(60000),
        hour: $lambda(3600000),
        day: $lambda(86400000),
        week: $lambda(608400000),
        month: function(month, year){
            var d = new Date;
            return Date.daysInMonth($pick(month, d.get('mo')), $pick(year, d.get('year'))) * 86400000;
        },
        year: function(year){
            year = year || new Date().get('year');
            return Date.isLeapYear(year) ? 31622400000 : 31536000000;
        }
    },

    daysInMonth: function(month, year){
        return [31, Date.isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
    },

    isLeapYear: function(year){
        return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);
    },

    parse: function(from){
        var t = $type(from);
        if (t == 'number') return new Date(from);
        if (t != 'string') return from;
        from = from.clean();
        if (!from.length) return null;

        var parsed;
        parsePatterns.some(function(pattern){
            var bits = pattern.re.exec(from);
            return (bits) ? (parsed = pattern.handler(bits)) : false;
        });

        return parsed || new Date(nativeParse(from));
    },

    parseDay: function(day, num){
        return parseWord('day', day, num);
    },

    parseMonth: function(month, num){
        return parseWord('month', month, num);
    },

    parseUTC: function(value){
        var localDate = new Date(value);
        var utcSeconds = Date.UTC(
            localDate.get('year'),
            localDate.get('mo'),
            localDate.get('date'),
            localDate.get('hr'),
            localDate.get('min'),
            localDate.get('sec')
        );
        return new Date(utcSeconds);
    },

    orderIndex: function(unit){
        return Date.getMsg('dateOrder').indexOf(unit) + 1;
    },

    defineFormat: function(name, format){
        formats[name] = format;
    },

    defineFormats: function(formats){
        for (var name in formats) Date.defineFormat(name, formats[name]);
    },

    parsePatterns: parsePatterns, // this is deprecated
    
    defineParser: function(pattern){
        parsePatterns.push((pattern.re && pattern.handler) ? pattern : build(pattern));
    },
    
    defineParsers: function(){
        Array.flatten(arguments).each(Date.defineParser);
    },
    
    define2DigitYearStart: function(year){
        startYear = year % 100;
        startCentury = year - startYear;
    }

});

var startCentury = 1900;
var startYear = 70;

var regexOf = function(type){
    return new RegExp('(?:' + Date.getMsg(type).map(function(name){
        return name.substr(0, 3);
    }).join('|') + ')[a-z]*');
};

var replacers = function(key){
    switch(key){
        case 'x': // iso8601 covers yyyy-mm-dd, so just check if month is first
            return ((Date.orderIndex('month') == 1) ? '%m[.-/]%d' : '%d[.-/]%m') + '([.-/]%y)?';
        case 'X':
            return '%H([.:]%M)?([.:]%S([.:]%s)?)? ?%p? ?%T?';
    }
    return null;
};

var keys = {
    d: /[0-2]?[0-9]|3[01]/,
    H: /[01]?[0-9]|2[0-3]/,
    I: /0?[1-9]|1[0-2]/,
    M: /[0-5]?\d/,
    s: /\d+/,
    o: /[a-z]*/,
    p: /[ap]\.?m\.?/,
    y: /\d{2}|\d{4}/,
    Y: /\d{4}/,
    T: /Z|[+-]\d{2}(?::?\d{2})?/
};

keys.m = keys.I;
keys.S = keys.M;

var currentLanguage;

var recompile = function(language){
    currentLanguage = language;
    
    keys.a = keys.A = regexOf('days');
    keys.b = keys.B = regexOf('months');
    
    parsePatterns.each(function(pattern, i){
        if (pattern.format) parsePatterns[i] = build(pattern.format);
    });
};

var build = function(format){
    if (!currentLanguage) return {format: format};
    
    var parsed = [];
    var re = (format.source || format) // allow format to be regex
     .replace(/%([a-z])/gi,
        function($0, $1){
            return replacers($1) || $0;
        }
    ).replace(/\((?!\?)/g, '(?:') // make all groups non-capturing
     .replace(/ (?!\?|\*)/g, ',? ') // be forgiving with spaces and commas
     .replace(/%([a-z%])/gi,
        function($0, $1){
            var p = keys[$1];
            if (!p) return $1;
            parsed.push($1);
            return '(' + p.source + ')';
        }
    ).replace(/\[a-z\]/gi, '[a-z\\u00c0-\\uffff]'); // handle unicode words

    return {
        format: format,
        re: new RegExp('^' + re + '$', 'i'),
        handler: function(bits){
            bits = bits.slice(1).associate(parsed);
            var date = new Date().clearTime();
            if ('d' in bits) handle.call(date, 'd', 1);
            if ('m' in bits) handle.call(date, 'm', 1);
            for (var key in bits) handle.call(date, key, bits[key]);
            return date;
        }
    };
};

var handle = function(key, value){
    if (!value) return this;

    switch(key){
        case 'a': case 'A': return this.set('day', Date.parseDay(value, true));
        case 'b': case 'B': return this.set('mo', Date.parseMonth(value, true));
        case 'd': return this.set('date', value);
        case 'H': case 'I': return this.set('hr', value);
        case 'm': return this.set('mo', value - 1);
        case 'M': return this.set('min', value);
        case 'p': return this.set('ampm', value.replace(/\./g, ''));
        case 'S': return this.set('sec', value);
        case 's': return this.set('ms', ('0.' + value) * 1000);
        case 'w': return this.set('day', value);
        case 'Y': return this.set('year', value);
        case 'y':
            value = +value;
            if (value < 100) value += startCentury + (value < startYear ? 100 : 0);
            return this.set('year', value);
        case 'T':
            if (value == 'Z') value = '+00';
            var offset = value.match(/([+-])(\d{2}):?(\d{2})?/);
            offset = (offset[1] + '1') * (offset[2] * 60 + (+offset[3] || 0)) + this.getTimezoneOffset();
            return this.set('time', this - offset * 60000);
    }

    return this;
};

Date.defineParsers(
    '%Y([-./]%m([-./]%d((T| )%X)?)?)?', // "1999-12-31", "1999-12-31 11:59pm", "1999-12-31 23:59:59", ISO8601
    '%Y%m%d(T%H(%M%S?)?)?', // "19991231", "19991231T1159", compact
    '%x( %X)?', // "12/31", "12.31.99", "12-31-1999", "12/31/2008 11:59 PM"
    '%d%o( %b( %Y)?)?( %X)?', // "31st", "31st December", "31 Dec 1999", "31 Dec 1999 11:59pm"
    '%b( %d%o)?( %Y)?( %X)?', // Same as above with month and day switched
    '%Y %b( %d%o( %X)?)?', // Same as above with year coming first
    '%o %b %d %X %T %Y' // "Thu Oct 22 08:11:23 +0000 2009"
);

MooTools.lang.addEvent('langChange', function(language){
    if (MooTools.lang.get('Date')) recompile(language);
}).fireEvent('langChange', MooTools.lang.getCurrentLanguage());

})();

/*
---

script: Hash.Extras.js

description: Extends the Hash native object to include getFromPath which allows a path notation to child elements.

license: MIT-style license

authors:
- Aaron Newton

requires:
- core:1.2.4/Hash.base
- /MooTools.More

provides: [Hash.Extras]

...
*/

Hash.implement({

    getFromPath: function(notation){
        var source = this.getClean();
        notation.replace(/\[([^\]]+)\]|\.([^.[]+)|[^[.]+/g, function(match){
            if (!source) return null;
            var prop = arguments[2] || arguments[1] || arguments[0];
            source = (prop in source) ? source[prop] : null;
            return match;
        });
        return source;
    },

    cleanValues: function(method){
        method = method || $defined;
        this.each(function(v, k){
            if (!method(v)) this.erase(k);
        }, this);
        return this;
    },

    run: function(){
        var args = arguments;
        this.each(function(v, k){
            if ($type(v) == 'function') v.run(args);
        });
    }

});

/*
---

script: String.Extras.js

description: Extends the String native object to include methods useful in managing various kinds of strings (query strings, urls, html, etc).

license: MIT-style license

authors:
- Aaron Newton
- Guillermo Rauch

requires:
- core:1.2.4/String
- core:1.2.4/$util
- core:1.2.4/Array

provides: [String.Extras]

...
*/

(function(){
  
var special = ['À','à','Á','á','Â','â','Ã','ã','Ä','ä','Å','å','Ă','ă','Ą','ą','Ć','ć','Č','č','Ç','ç', 'Ď','ď','Đ','đ', 'È','è','É','é','Ê','ê','Ë','ë','Ě','ě','Ę','ę', 'Ğ','ğ','Ì','ì','Í','í','Î','î','Ï','ï', 'Ĺ','ĺ','Ľ','ľ','Ł','ł', 'Ñ','ñ','Ň','ň','Ń','ń','Ò','ò','Ó','ó','Ô','ô','Õ','õ','Ö','ö','Ø','ø','ő','Ř','ř','Ŕ','ŕ','Š','š','Ş','ş','Ś','ś', 'Ť','ť','Ť','ť','Ţ','ţ','Ù','ù','Ú','ú','Û','û','Ü','ü','Ů','ů', 'Ÿ','ÿ','ý','Ý','Ž','ž','Ź','ź','Ż','ż', 'Þ','þ','Ð','ð','ß','Œ','œ','Æ','æ','µ'];

var standard = ['A','a','A','a','A','a','A','a','Ae','ae','A','a','A','a','A','a','C','c','C','c','C','c','D','d','D','d', 'E','e','E','e','E','e','E','e','E','e','E','e','G','g','I','i','I','i','I','i','I','i','L','l','L','l','L','l', 'N','n','N','n','N','n', 'O','o','O','o','O','o','O','o','Oe','oe','O','o','o', 'R','r','R','r', 'S','s','S','s','S','s','T','t','T','t','T','t', 'U','u','U','u','U','u','Ue','ue','U','u','Y','y','Y','y','Z','z','Z','z','Z','z','TH','th','DH','dh','ss','OE','oe','AE','ae','u'];

var tidymap = {
    "[\xa0\u2002\u2003\u2009]": " ",
    "\xb7": "*",
    "[\u2018\u2019]": "'",
    "[\u201c\u201d]": '"',
    "\u2026": "...",
    "\u2013": "-",
    "\u2014": "--",
    "\uFFFD": "&raquo;"
};

var getRegForTag = function(tag, contents) {
    tag = tag || '';
    var regstr = contents ? "<" + tag + "[^>]*>([\\s\\S]*?)<\/" + tag + ">" : "<\/?" + tag + "([^>]+)?>";
    reg = new RegExp(regstr, "gi");
    return reg;
};

String.implement({

    standardize: function(){
        var text = this;
        special.each(function(ch, i){
            text = text.replace(new RegExp(ch, 'g'), standard[i]);
        });
        return text;
    },

    repeat: function(times){
        return new Array(times + 1).join(this);
    },

    pad: function(length, str, dir){
        if (this.length >= length) return this;
        var pad = (str == null ? ' ' : '' + str).repeat(length - this.length).substr(0, length - this.length);
        if (!dir || dir == 'right') return this + pad;
        if (dir == 'left') return pad + this;
        return pad.substr(0, (pad.length / 2).floor()) + this + pad.substr(0, (pad.length / 2).ceil());
    },

    getTags: function(tag, contents){
        return this.match(getRegForTag(tag, contents)) || [];
    },

    stripTags: function(tag, contents){
        return this.replace(getRegForTag(tag, contents), '');
    },

    tidy: function(){
        var txt = this.toString();
        $each(tidymap, function(value, key){
            txt = txt.replace(new RegExp(key, 'g'), value);
        });
        return txt;
    }

});

})();

/*
---

script: String.QueryString.js

description: Methods for dealing with URI query strings.

license: MIT-style license

authors:
- Sebastian Markbåge, Aaron Newton, Lennart Pilon, Valerio Proietti

requires:
- core:1.2.4/Array
- core:1.2.4/String
- /MooTools.More

provides: [String.QueryString]

...
*/

String.implement({

    parseQueryString: function(){
        var vars = this.split(/[&;]/), res = {};
        if (vars.length) vars.each(function(val){
            var index = val.indexOf('='),
                keys = index < 0 ? [''] : val.substr(0, index).match(/[^\]\[]+/g),
                value = decodeURIComponent(val.substr(index + 1)),
                obj = res;
            keys.each(function(key, i){
                var current = obj[key];
                if(i < keys.length - 1)
                    obj = obj[key] = current || {};
                else if($type(current) == 'array')
                    current.push(value);
                else
                    obj[key] = $defined(current) ? [current, value] : value;
            });
        });
        return res;
    },

    cleanQueryString: function(method){
        return this.split('&').filter(function(val){
            var index = val.indexOf('='),
            key = index < 0 ? '' : val.substr(0, index),
            value = val.substr(index + 1);
            return method ? method.run([key, value]) : $chk(value);
        }).join('&');
    }

});

/*
---

script: URI.js

description: Provides methods useful in managing the window location and uris.

license: MIT-style license

authors:
- Sebastian Markb�ge
- Aaron Newton

requires:
- core:1.2.4/Selectors
- /String.QueryString

provides: URI

...
*/

var URI = new Class({

    Implements: Options,

    options: {
        /*base: false*/
    },

    regex: /^(?:(\w+):)?(?:\/\/(?:(?:([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)?(\.\.?$|(?:[^?#\/]*\/)*)([^?#]*)(?:\?([^#]*))?(?:#(.*))?/,
    parts: ['scheme', 'user', 'password', 'host', 'port', 'directory', 'file', 'query', 'fragment'],
    schemes: {http: 80, https: 443, ftp: 21, rtsp: 554, mms: 1755, file: 0},

    initialize: function(uri, options){
        this.setOptions(options);
        var base = this.options.base || URI.base;
        if(!uri) uri = base;
        
        if (uri && uri.parsed) this.parsed = $unlink(uri.parsed);
        else this.set('value', uri.href || uri.toString(), base ? new URI(base) : false);
    },

    parse: function(value, base){
        var bits = value.match(this.regex);
        if (!bits) return false;
        bits.shift();
        return this.merge(bits.associate(this.parts), base);
    },

    merge: function(bits, base){
        if ((!bits || !bits.scheme) && (!base || !base.scheme)) return false;
        if (base){
            this.parts.every(function(part){
                if (bits[part]) return false;
                bits[part] = base[part] || '';
                return true;
            });
        }
        bits.port = bits.port || this.schemes[bits.scheme.toLowerCase()];
        bits.directory = bits.directory ? this.parseDirectory(bits.directory, base ? base.directory : '') : '/';
        return bits;
    },

    parseDirectory: function(directory, baseDirectory) {
        directory = (directory.substr(0, 1) == '/' ? '' : (baseDirectory || '/')) + directory;
        if (!directory.test(URI.regs.directoryDot)) return directory;
        var result = [];
        directory.replace(URI.regs.endSlash, '').split('/').each(function(dir){
            if (dir == '..' && result.length > 0) result.pop();
            else if (dir != '.') result.push(dir);
        });
        return result.join('/') + '/';
    },

    combine: function(bits){
        return bits.value || bits.scheme + '://' +
            (bits.user ? bits.user + (bits.password ? ':' + bits.password : '') + '@' : '') +
            (bits.host || '') + (bits.port && bits.port != this.schemes[bits.scheme] ? ':' + bits.port : '') +
            (bits.directory || '/') + (bits.file || '') +
            (bits.query ? '?' + bits.query : '') +
            (bits.fragment ? '#' + bits.fragment : '');
    },

    set: function(part, value, base){
        if (part == 'value'){
            var scheme = value.match(URI.regs.scheme);
            if (scheme) scheme = scheme[1];
            if (scheme && !$defined(this.schemes[scheme.toLowerCase()])) this.parsed = { scheme: scheme, value: value };
            else this.parsed = this.parse(value, (base || this).parsed) || (scheme ? { scheme: scheme, value: value } : { value: value });
        } else if (part == 'data') {
            this.setData(value);
        } else {
            this.parsed[part] = value;
        }
        return this;
    },

    get: function(part, base){
        switch(part){
            case 'value': return this.combine(this.parsed, base ? base.parsed : false);
            case 'data' : return this.getData();
        }
        return this.parsed[part] || '';
    },

    go: function(){
        document.location.href = this.toString();
    },

    toURI: function(){
        return this;
    },

    getData: function(key, part){
        var qs = this.get(part || 'query');
        if (!$chk(qs)) return key ? null : {};
        var obj = qs.parseQueryString();
        return key ? obj[key] : obj;
    },

    setData: function(values, merge, part){
        if (typeof values == 'string'){
            values = this.getData();
            values[arguments[0]] = arguments[1];
        } else if (merge) {
            values = $merge(this.getData(), values);
        }
        return this.set(part || 'query', Hash.toQueryString(values));
    },

    clearData: function(part){
        return this.set(part || 'query', '');
    }

});

URI.prototype.toString = URI.prototype.valueOf = function(){
    return this.get('value');
};

URI.regs = {
    endSlash: /\/$/,
    scheme: /^(\w+):/,
    directoryDot: /\.\/|\.$/
};

URI.base = new URI(document.getElements('base[href]', true).getLast(), {base: document.location});

String.implement({

    toURI: function(options){
        return new URI(this, options);
    }

});

/*
---

script: URI.Relative.js

description: Extends the URI class to add methods for computing relative and absolute urls.

license: MIT-style license

authors:
- Sebastian Markbåge


requires:
- /Class.refactor
- /URI

provides: [URI.Relative]

...
*/

URI = Class.refactor(URI, {

    combine: function(bits, base){
        if (!base || bits.scheme != base.scheme || bits.host != base.host || bits.port != base.port)
            return this.previous.apply(this, arguments);
        var end = bits.file + (bits.query ? '?' + bits.query : '') + (bits.fragment ? '#' + bits.fragment : '');

        if (!base.directory) return (bits.directory || (bits.file ? '' : './')) + end;

        var baseDir = base.directory.split('/'),
            relDir = bits.directory.split('/'),
            path = '',
            offset;

        var i = 0;
        for(offset = 0; offset < baseDir.length && offset < relDir.length && baseDir[offset] == relDir[offset]; offset++);
        for(i = 0; i < baseDir.length - offset - 1; i++) path += '../';
        for(i = offset; i < relDir.length - 1; i++) path += relDir[i] + '/';

        return (path || (bits.file ? '' : './')) + end;
    },

    toAbsolute: function(base){
        base = new URI(base);
        if (base) base.set('directory', '').set('file', '');
        return this.toRelative(base);
    },

    toRelative: function(base){
        return this.get('value', new URI(base));
    }

});

/*
---

script: Element.Measure.js

description: Extends the Element native object to include methods useful in measuring dimensions.

credits: "Element.measure / .expose methods by Daniel Steigerwald License: MIT-style license. Copyright: Copyright (c) 2008 Daniel Steigerwald, daniel.steigerwald.cz"

license: MIT-style license

authors:
- Aaron Newton

requires:
- core:1.2.4/Element.Style
- core:1.2.4/Element.Dimensions
- /MooTools.More

provides: [Element.Measure]

...
*/

Element.implement({

    measure: function(fn){
        var vis = function(el) {
            return !!(!el || el.offsetHeight || el.offsetWidth);
        };
        if (vis(this)) return fn.apply(this);
        var parent = this.getParent(),
            restorers = [],
            toMeasure = []; 
        while (!vis(parent) && parent != document.body) {
            toMeasure.push(parent.expose());
            parent = parent.getParent();
        }
        var restore = this.expose();
        var result = fn.apply(this);
        restore();
        toMeasure.each(function(restore){
            restore();
        });
        return result;
    },

    expose: function(){
        if (this.getStyle('display') != 'none') return $empty;
        var before = this.style.cssText;
        this.setStyles({
            display: 'block',
            position: 'absolute',
            visibility: 'hidden'
        });
        return function(){
            this.style.cssText = before;
        }.bind(this);
    },

    getDimensions: function(options){
        options = $merge({computeSize: false},options);
        var dim = {};
        var getSize = function(el, options){
            return (options.computeSize)?el.getComputedSize(options):el.getSize();
        };
        var parent = this.getParent('body');
        if (parent && this.getStyle('display') == 'none'){
            dim = this.measure(function(){
                return getSize(this, options);
            });
        } else if (parent){
            try { //safari sometimes crashes here, so catch it
                dim = getSize(this, options);
            }catch(e){}
        } else {
            dim = {x: 0, y: 0};
        }
        return $chk(dim.x) ? $extend(dim, {width: dim.x, height: dim.y}) : $extend(dim, {x: dim.width, y: dim.height});
    },

    getComputedSize: function(options){
        options = $merge({
            styles: ['padding','border'],
            plains: {
                height: ['top','bottom'],
                width: ['left','right']
            },
            mode: 'both'
        }, options);
        var size = {width: 0,height: 0};
        switch (options.mode){
            case 'vertical':
                delete size.width;
                delete options.plains.width;
                break;
            case 'horizontal':
                delete size.height;
                delete options.plains.height;
                break;
        }
        var getStyles = [];
        //this function might be useful in other places; perhaps it should be outside this function?
        $each(options.plains, function(plain, key){
            plain.each(function(edge){
                options.styles.each(function(style){
                    getStyles.push((style == 'border') ? style + '-' + edge + '-' + 'width' : style + '-' + edge);
                });
            });
        });
        var styles = {};
        getStyles.each(function(style){ styles[style] = this.getComputedStyle(style); }, this);
        var subtracted = [];
        $each(options.plains, function(plain, key){ //keys: width, height, plains: ['left', 'right'], ['top','bottom']
            var capitalized = key.capitalize();
            size['total' + capitalized] = size['computed' + capitalized] = 0;
            plain.each(function(edge){ //top, left, right, bottom
                size['computed' + edge.capitalize()] = 0;
                getStyles.each(function(style, i){ //padding, border, etc.
                    //'padding-left'.test('left') size['totalWidth'] = size['width'] + [padding-left]
                    if (style.test(edge)){
                        styles[style] = styles[style].toInt() || 0; //styles['padding-left'] = 5;
                        size['total' + capitalized] = size['total' + capitalized] + styles[style];
                        size['computed' + edge.capitalize()] = size['computed' + edge.capitalize()] + styles[style];
                    }
                    //if width != width (so, padding-left, for instance), then subtract that from the total
                    if (style.test(edge) && key != style &&
                        (style.test('border') || style.test('padding')) && !subtracted.contains(style)){
                        subtracted.push(style);
                        size['computed' + capitalized] = size['computed' + capitalized]-styles[style];
                    }
                });
            });
        });

        ['Width', 'Height'].each(function(value){
            var lower = value.toLowerCase();
            if(!$chk(size[lower])) return;

            size[lower] = size[lower] + this['offset' + value] + size['computed' + value];
            size['total' + value] = size[lower] + size['total' + value];
            delete size['computed' + value];
        }, this);

        return $extend(styles, size);
    }

});

/*
---

script: Element.Position.js

description: Extends the Element native object to include methods useful positioning elements relative to others.

license: MIT-style license

authors:
- Aaron Newton

requires:
- core:1.2.4/Element.Dimensions
- /Element.Measure

provides: [Elements.Position]

...
*/

(function(){

var original = Element.prototype.position;

Element.implement({

    position: function(options){
        //call original position if the options are x/y values
        if (options && ($defined(options.x) || $defined(options.y))) return original ? original.apply(this, arguments) : this;
        $each(options||{}, function(v, k){ if (!$defined(v)) delete options[k]; });
        options = $merge({
            // minimum: { x: 0, y: 0 },
            // maximum: { x: 0, y: 0},
            relativeTo: document.body,
            position: {
                x: 'center', //left, center, right
                y: 'center' //top, center, bottom
            },
            edge: false,
            offset: {x: 0, y: 0},
            returnPos: false,
            relFixedPosition: false,
            ignoreMargins: false,
            ignoreScroll: false,
            allowNegative: false
        }, options);
        //compute the offset of the parent positioned element if this element is in one
        var parentOffset = {x: 0, y: 0}, 
                parentPositioned = false;
        /* dollar around getOffsetParent should not be necessary, but as it does not return
         * a mootools extended element in IE, an error occurs on the call to expose. See:
         * http://mootools.lighthouseapp.com/projects/2706/tickets/333-element-getoffsetparent-inconsistency-between-ie-and-other-browsers */
        var offsetParent = this.measure(function(){
            return document.id(this.getOffsetParent());
        });
        if (offsetParent && offsetParent != this.getDocument().body){
            parentOffset = offsetParent.measure(function(){
                return this.getPosition();
            });
            parentPositioned = offsetParent != document.id(options.relativeTo);
            options.offset.x = options.offset.x - parentOffset.x;
            options.offset.y = options.offset.y - parentOffset.y;
        }
        //upperRight, bottomRight, centerRight, upperLeft, bottomLeft, centerLeft
        //topRight, topLeft, centerTop, centerBottom, center
        var fixValue = function(option){
            if ($type(option) != 'string') return option;
            option = option.toLowerCase();
            var val = {};
            if (option.test('left')) val.x = 'left';
            else if (option.test('right')) val.x = 'right';
            else val.x = 'center';
            if (option.test('upper') || option.test('top')) val.y = 'top';
            else if (option.test('bottom')) val.y = 'bottom';
            else val.y = 'center';
            return val;
        };
        options.edge = fixValue(options.edge);
        options.position = fixValue(options.position);
        if (!options.edge){
            if (options.position.x == 'center' && options.position.y == 'center') options.edge = {x:'center', y:'center'};
            else options.edge = {x:'left', y:'top'};
        }

        this.setStyle('position', 'absolute');
        var rel = document.id(options.relativeTo) || document.body,
                calc = rel == document.body ? window.getScroll() : rel.getPosition(),
                top = calc.y, left = calc.x;

        var scrolls = rel.getScrolls();
        top += scrolls.y;
        left += scrolls.x;

        var dim = this.getDimensions({computeSize: true, styles:['padding', 'border','margin']});
        var pos = {},
                prefY = options.offset.y,
                prefX = options.offset.x,
                winSize = window.getSize();
        switch(options.position.x){
            case 'left':
                pos.x = left + prefX;
                break;
            case 'right':
                pos.x = left + prefX + rel.offsetWidth;
                break;
            default: //center
                pos.x = left + ((rel == document.body ? winSize.x : rel.offsetWidth)/2) + prefX;
                break;
        }
        switch(options.position.y){
            case 'top':
                pos.y = top + prefY;
                break;
            case 'bottom':
                pos.y = top + prefY + rel.offsetHeight;
                break;
            default: //center
                pos.y = top + ((rel == document.body ? winSize.y : rel.offsetHeight)/2) + prefY;
                break;
        }
        if (options.edge){
            var edgeOffset = {};

            switch(options.edge.x){
                case 'left':
                    edgeOffset.x = 0;
                    break;
                case 'right':
                    edgeOffset.x = -dim.x-dim.computedRight-dim.computedLeft;
                    break;
                default: //center
                    edgeOffset.x = -(dim.totalWidth/2);
                    break;
            }
            switch(options.edge.y){
                case 'top':
                    edgeOffset.y = 0;
                    break;
                case 'bottom':
                    edgeOffset.y = -dim.y-dim.computedTop-dim.computedBottom;
                    break;
                default: //center
                    edgeOffset.y = -(dim.totalHeight/2);
                    break;
            }
            pos.x += edgeOffset.x;
            pos.y += edgeOffset.y;
        }
        pos = {
            left: ((pos.x >= 0 || parentPositioned || options.allowNegative) ? pos.x : 0).toInt(),
            top: ((pos.y >= 0 || parentPositioned || options.allowNegative) ? pos.y : 0).toInt()
        };
        var xy = {left: 'x', top: 'y'};
        ['minimum', 'maximum'].each(function(minmax) {
            ['left', 'top'].each(function(lr) {
                var val = options[minmax] ? options[minmax][xy[lr]] : null;
                if (val != null && pos[lr] < val) pos[lr] = val;
            });
        });
        if (rel.getStyle('position') == 'fixed' || options.relFixedPosition){
            var winScroll = window.getScroll();
            pos.top+= winScroll.y;
            pos.left+= winScroll.x;
        }
        if (options.ignoreScroll) {
            var relScroll = rel.getScroll();
            pos.top-= relScroll.y;
            pos.left-= relScroll.x;
        }
        if (options.ignoreMargins) {
            pos.left += (
                options.edge.x == 'right' ? dim['margin-right'] : 
                options.edge.x == 'center' ? -dim['margin-left'] + ((dim['margin-right'] + dim['margin-left'])/2) : 
                    - dim['margin-left']
            );
            pos.top += (
                options.edge.y == 'bottom' ? dim['margin-bottom'] : 
                options.edge.y == 'center' ? -dim['margin-top'] + ((dim['margin-bottom'] + dim['margin-top'])/2) : 
                    - dim['margin-top']
            );
        }
        pos.left = Math.ceil(pos.left);
        pos.top = Math.ceil(pos.top);
        if (options.returnPos) return pos;
        else this.setStyles(pos);
        return this;
    }

});

})();

/*
---

script: Element.Shortcuts.js

description: Extends the Element native object to include some shortcut methods.

license: MIT-style license

authors:
- Aaron Newton

requires:
- core:1.2.4/Element.Style
- /MooTools.More

provides: [Element.Shortcuts]

...
*/

Element.implement({

    isDisplayed: function(){
        return this.getStyle('display') != 'none';
    },

    isVisible: function(){
        var w = this.offsetWidth,
            h = this.offsetHeight;
        return (w == 0 && h == 0) ? false : (w > 0 && h > 0) ? true : this.isDisplayed();
    },

    toggle: function(){
        return this[this.isDisplayed() ? 'hide' : 'show']();
    },

    hide: function(){
        var d;
        try {
            // IE fails here if the element is not in the dom
            if ((d = this.getStyle('display')) == 'none') d = null;
        } catch(e){}
        
        return this.store('originalDisplay', d || 'block').setStyle('display', 'none');
    },

    show: function(display){
        return this.setStyle('display', display || this.retrieve('originalDisplay') || 'block');
    },

    swapClass: function(remove, add){
        return this.removeClass(remove).addClass(add);
    }

});


/*
---

script: Fx.Elements.js

description: Effect to change any number of CSS properties of any number of Elements.

license: MIT-style license

authors:
- Valerio Proietti

requires:
- core:1.2.4/Fx.CSS
- /MooTools.More

provides: [Fx.Elements]

...
*/

Fx.Elements = new Class({

    Extends: Fx.CSS,

    initialize: function(elements, options){
        this.elements = this.subject = $$(elements);
        this.parent(options);
    },

    compute: function(from, to, delta){
        var now = {};
        for (var i in from){
            var iFrom = from[i], iTo = to[i], iNow = now[i] = {};
            for (var p in iFrom) iNow[p] = this.parent(iFrom[p], iTo[p], delta);
        }
        return now;
    },

    set: function(now){
        for (var i in now){
            var iNow = now[i];
            for (var p in iNow) this.render(this.elements[i], p, iNow[p], this.options.unit);
        }
        return this;
    },

    start: function(obj){
        if (!this.check(obj)) return this;
        var from = {}, to = {};
        for (var i in obj){
            var iProps = obj[i], iFrom = from[i] = {}, iTo = to[i] = {};
            for (var p in iProps){
                var parsed = this.prepare(this.elements[i], p, iProps[p]);
                iFrom[p] = parsed.from;
                iTo[p] = parsed.to;
            }
        }
        return this.parent(from, to);
    }

});

/*
---

script: Fx.Accordion.js

description: An Fx.Elements extension which allows you to easily create accordion type controls.

license: MIT-style license

authors:
- Valerio Proietti

requires:
- core:1.2.4/Element.Event
- /Fx.Elements

provides: [Fx.Accordion]

...
*/

var Accordion = Fx.Accordion = new Class({

    Extends: Fx.Elements,

    options: {/*
        onActive: $empty(toggler, section),
        onBackground: $empty(toggler, section),
        fixedHeight: false,
        fixedWidth: false,
        */
        display: 0,
        show: false,
        height: true,
        width: false,
        opacity: true,
        alwaysHide: false,
        trigger: 'click',
        initialDisplayFx: true,
        returnHeightToAuto: true
    },

    initialize: function(){
        var params = Array.link(arguments, {'container': Element.type, 'options': Object.type, 'togglers': $defined, 'elements': $defined});
        this.parent(params.elements, params.options);
        this.togglers = $$(params.togglers);
        this.container = document.id(params.container);
        this.previous = -1;
        this.internalChain = new Chain();
        if (this.options.alwaysHide) this.options.wait = true;
        if ($chk(this.options.show)){
            this.options.display = false;
            this.previous = this.options.show;
        }
        if (this.options.start){
            this.options.display = false;
            this.options.show = false;
        }
        this.effects = {};
        if (this.options.opacity) this.effects.opacity = 'fullOpacity';
        if (this.options.width) this.effects.width = this.options.fixedWidth ? 'fullWidth' : 'offsetWidth';
        if (this.options.height) this.effects.height = this.options.fixedHeight ? 'fullHeight' : 'scrollHeight';
        for (var i = 0, l = this.togglers.length; i < l; i++) this.addSection(this.togglers[i], this.elements[i]);
        this.elements.each(function(el, i){
            if (this.options.show === i){
                this.fireEvent('active', [this.togglers[i], el]);
            } else {
                for (var fx in this.effects) el.setStyle(fx, 0);
            }
        }, this);
        if ($chk(this.options.display)) this.display(this.options.display, this.options.initialDisplayFx);
        this.addEvent('complete', this.internalChain.callChain.bind(this.internalChain));
    },

    addSection: function(toggler, element){
        toggler = document.id(toggler);
        element = document.id(element);
        var test = this.togglers.contains(toggler);
        this.togglers.include(toggler);
        this.elements.include(element);
        var idx = this.togglers.indexOf(toggler);
        var displayer = this.display.bind(this, idx);
        toggler.store('accordion:display', displayer);
        toggler.addEvent(this.options.trigger, displayer);
        if (this.options.height) element.setStyles({'padding-top': 0, 'border-top': 'none', 'padding-bottom': 0, 'border-bottom': 'none'});
        if (this.options.width) element.setStyles({'padding-left': 0, 'border-left': 'none', 'padding-right': 0, 'border-right': 'none'});
        element.fullOpacity = 1;
        if (this.options.fixedWidth) element.fullWidth = this.options.fixedWidth;
        if (this.options.fixedHeight) element.fullHeight = this.options.fixedHeight;
        element.setStyle('overflow', 'hidden');
        if (!test){
            for (var fx in this.effects) element.setStyle(fx, 0);
        }
        return this;
    },

    detach: function(){
        this.togglers.each(function(toggler) {
            toggler.removeEvent(this.options.trigger, toggler.retrieve('accordion:display'));
        }, this);
    },

    display: function(index, useFx){
        if (!this.check(index, useFx)) return this;
        useFx = $pick(useFx, true);
        if (this.options.returnHeightToAuto){
            var prev = this.elements[this.previous];
            if (prev && !this.selfHidden){
                for (var fx in this.effects){
                    prev.setStyle(fx, prev[this.effects[fx]]);
                }
            }
        }
        index = ($type(index) == 'element') ? this.elements.indexOf(index) : index;
        if ((this.timer && this.options.wait) || (index === this.previous && !this.options.alwaysHide)) return this;
        this.previous = index;
        var obj = {};
        this.elements.each(function(el, i){
            obj[i] = {};
            var hide;
            if (i != index){
                hide = true;
            } else if (this.options.alwaysHide && ((el.offsetHeight > 0 && this.options.height) || el.offsetWidth > 0 && this.options.width)){
                hide = true;
                this.selfHidden = true;
            }
            this.fireEvent(hide ? 'background' : 'active', [this.togglers[i], el]);
            for (var fx in this.effects) obj[i][fx] = hide ? 0 : el[this.effects[fx]];
        }, this);
        this.internalChain.chain(function(){
            if (this.options.returnHeightToAuto && !this.selfHidden){
                var el = this.elements[index];
                if (el) el.setStyle('height', 'auto');
            };
        }.bind(this));
        return useFx ? this.start(obj) : this.set(obj);
    }

});

/*
---

script: Drag.js

description: The base Drag Class. Can be used to drag and resize Elements using mouse events.

license: MIT-style license

authors:
- Valerio Proietti
- Tom Occhinno
- Jan Kassens

requires:
- core:1.2.4/Events
- core:1.2.4/Options
- core:1.2.4/Element.Event
- core:1.2.4/Element.Style
- /MooTools.More

provides: [Drag]

*/

var Drag = new Class({

    Implements: [Events, Options],

    options: {/*
        onBeforeStart: $empty(thisElement),
        onStart: $empty(thisElement, event),
        onSnap: $empty(thisElement)
        onDrag: $empty(thisElement, event),
        onCancel: $empty(thisElement),
        onComplete: $empty(thisElement, event),*/
        snap: 6,
        unit: 'px',
        grid: false,
        style: true,
        limit: false,
        handle: false,
        invert: false,
        preventDefault: false,
        stopPropagation: false,
        modifiers: {x: 'left', y: 'top'}
    },

    initialize: function(){
        var params = Array.link(arguments, {'options': Object.type, 'element': $defined});
        this.element = document.id(params.element);
        this.document = this.element.getDocument();
        this.setOptions(params.options || {});
        var htype = $type(this.options.handle);
        this.handles = ((htype == 'array' || htype == 'collection') ? $$(this.options.handle) : document.id(this.options.handle)) || this.element;
        this.mouse = {'now': {}, 'pos': {}};
        this.value = {'start': {}, 'now': {}};

        this.selection = (Browser.Engine.trident) ? 'selectstart' : 'mousedown';

        this.bound = {
            start: this.start.bind(this),
            check: this.check.bind(this),
            drag: this.drag.bind(this),
            stop: this.stop.bind(this),
            cancel: this.cancel.bind(this),
            eventStop: $lambda(false)
        };
        this.attach();
    },

    attach: function(){
        this.handles.addEvent('mousedown', this.bound.start);
        return this;
    },

    detach: function(){
        this.handles.removeEvent('mousedown', this.bound.start);
        return this;
    },

    start: function(event){
        if (event.rightClick) return;
        if (this.options.preventDefault) event.preventDefault();
        if (this.options.stopPropagation) event.stopPropagation();
        this.mouse.start = event.page;
        this.fireEvent('beforeStart', this.element);
        var limit = this.options.limit;
        this.limit = {x: [], y: []};
        for (var z in this.options.modifiers){
            if (!this.options.modifiers[z]) continue;
            if (this.options.style) this.value.now[z] = this.element.getStyle(this.options.modifiers[z]).toInt();
            else this.value.now[z] = this.element[this.options.modifiers[z]];
            if (this.options.invert) this.value.now[z] *= -1;
            this.mouse.pos[z] = event.page[z] - this.value.now[z];
            if (limit && limit[z]){
                for (var i = 2; i--; i){
                    if ($chk(limit[z][i])) this.limit[z][i] = $lambda(limit[z][i])();
                }
            }
        }
        if ($type(this.options.grid) == 'number') this.options.grid = {x: this.options.grid, y: this.options.grid};
        this.document.addEvents({mousemove: this.bound.check, mouseup: this.bound.cancel});
        this.document.addEvent(this.selection, this.bound.eventStop);
    },

    check: function(event){
        if (this.options.preventDefault) event.preventDefault();
        var distance = Math.round(Math.sqrt(Math.pow(event.page.x - this.mouse.start.x, 2) + Math.pow(event.page.y - this.mouse.start.y, 2)));
        if (distance > this.options.snap){
            this.cancel();
            this.document.addEvents({
                mousemove: this.bound.drag,
                mouseup: this.bound.stop
            });
            this.fireEvent('start', [this.element, event]).fireEvent('snap', this.element);
        }
    },

    drag: function(event){
        if (this.options.preventDefault) event.preventDefault();
        this.mouse.now = event.page;
        for (var z in this.options.modifiers){
            if (!this.options.modifiers[z]) continue;
            this.value.now[z] = this.mouse.now[z] - this.mouse.pos[z];
            if (this.options.invert) this.value.now[z] *= -1;
            if (this.options.limit && this.limit[z]){
                if ($chk(this.limit[z][1]) && (this.value.now[z] > this.limit[z][1])){
                    this.value.now[z] = this.limit[z][1];
                } else if ($chk(this.limit[z][0]) && (this.value.now[z] < this.limit[z][0])){
                    this.value.now[z] = this.limit[z][0];
                }
            }
            if (this.options.grid[z]) this.value.now[z] -= ((this.value.now[z] - (this.limit[z][0]||0)) % this.options.grid[z]);
            if (this.options.style) {
                this.element.setStyle(this.options.modifiers[z], this.value.now[z] + this.options.unit);
            } else {
                this.element[this.options.modifiers[z]] = this.value.now[z];
            }
        }
        this.fireEvent('drag', [this.element, event]);
    },

    cancel: function(event){
        this.document.removeEvent('mousemove', this.bound.check);
        this.document.removeEvent('mouseup', this.bound.cancel);
        if (event){
            this.document.removeEvent(this.selection, this.bound.eventStop);
            this.fireEvent('cancel', this.element);
        }
    },

    stop: function(event){
        this.document.removeEvent(this.selection, this.bound.eventStop);
        this.document.removeEvent('mousemove', this.bound.drag);
        this.document.removeEvent('mouseup', this.bound.stop);
        if (event) this.fireEvent('complete', [this.element, event]);
    }

});

Element.implement({

    makeResizable: function(options){
        var drag = new Drag(this, $merge({modifiers: {x: 'width', y: 'height'}}, options));
        this.store('resizer', drag);
        return drag.addEvent('drag', function(){
            this.fireEvent('resize', drag);
        }.bind(this));
    }

});


/*
---

script: Drag.Move.js

description: A Drag extension that provides support for the constraining of draggables to containers and droppables.

license: MIT-style license

authors:
- Valerio Proietti
- Tom Occhinno
- Jan Kassens
- Aaron Newton
- Scott Kyle

requires:
- core:1.2.4/Element.Dimensions
- /Drag

provides: [Drag.Move]

...
*/

Drag.Move = new Class({

    Extends: Drag,

    options: {/*
        onEnter: $empty(thisElement, overed),
        onLeave: $empty(thisElement, overed),
        onDrop: $empty(thisElement, overed, event),*/
        droppables: [],
        container: false,
        precalculate: false,
        includeMargins: true,
        checkDroppables: true
    },

    initialize: function(element, options){
        this.parent(element, options);
        element = this.element;
        
        this.droppables = $$(this.options.droppables);
        this.container = document.id(this.options.container);
        
        if (this.container && $type(this.container) != 'element')
            this.container = document.id(this.container.getDocument().body);
        
        var styles = element.getStyles('left', 'right', 'position');
        if (styles.left == 'auto' || styles.top == 'auto')
            element.setPosition(element.getPosition(element.getOffsetParent()));
        
        if (styles.position == 'static')
            element.setStyle('position', 'absolute');

        this.addEvent('start', this.checkDroppables, true);

        this.overed = null;
    },

    start: function(event){
        if (this.container) this.options.limit = this.calculateLimit();
        
        if (this.options.precalculate){
            this.positions = this.droppables.map(function(el){
                return el.getCoordinates();
            });
        }
        
        this.parent(event);
    },
    
    calculateLimit: function(){
        var offsetParent = this.element.getOffsetParent(),
            containerCoordinates = this.container.getCoordinates(offsetParent),
            containerBorder = {},
            elementMargin = {},
            elementBorder = {},
            containerMargin = {},
            offsetParentPadding = {};

        ['top', 'right', 'bottom', 'left'].each(function(pad){
            containerBorder[pad] = this.container.getStyle('border-' + pad).toInt();
            elementBorder[pad] = this.element.getStyle('border-' + pad).toInt();
            elementMargin[pad] = this.element.getStyle('margin-' + pad).toInt();
            containerMargin[pad] = this.container.getStyle('margin-' + pad).toInt();
            offsetParentPadding[pad] = offsetParent.getStyle('padding-' + pad).toInt();
        }, this);

        var width = this.element.offsetWidth + elementMargin.left + elementMargin.right,
            height = this.element.offsetHeight + elementMargin.top + elementMargin.bottom,
            left = 0,
            top = 0,
            right = containerCoordinates.right - containerBorder.right - width,
            bottom = containerCoordinates.bottom - containerBorder.bottom - height;

        if (this.options.includeMargins){
            left += elementMargin.left;
            top += elementMargin.top;
        } else {
            right += elementMargin.right;
            bottom += elementMargin.bottom;
        }
        
        if (this.element.getStyle('position') == 'relative'){
            var coords = this.element.getCoordinates(offsetParent);
            coords.left -= this.element.getStyle('left').toInt();
            coords.top -= this.element.getStyle('top').toInt();
            
            left += containerBorder.left - coords.left;
            top += containerBorder.top - coords.top;
            right += elementMargin.left - coords.left;
            bottom += elementMargin.top - coords.top;
            
            if (this.container != offsetParent){
                left += containerMargin.left + offsetParentPadding.left;
                top += (Browser.Engine.trident4 ? 0 : containerMargin.top) + offsetParentPadding.top;
            }
        } else {
            left -= elementMargin.left;
            top -= elementMargin.top;
            
            if (this.container == offsetParent){
                right -= containerBorder.left;
                bottom -= containerBorder.top;
            } else {
                left += containerCoordinates.left + containerBorder.left;
                top += containerCoordinates.top + containerBorder.top;
            }
        }
        
        return {
            x: [left, right],
            y: [top, bottom]
        };
    },

    checkAgainst: function(el, i){
        el = (this.positions) ? this.positions[i] : el.getCoordinates();
        var now = this.mouse.now;
        return (now.x > el.left && now.x < el.right && now.y < el.bottom && now.y > el.top);
    },

    checkDroppables: function(){
        var overed = this.droppables.filter(this.checkAgainst, this).getLast();
        if (this.overed != overed){
            if (this.overed) this.fireEvent('leave', [this.element, this.overed]);
            if (overed) this.fireEvent('enter', [this.element, overed]);
            this.overed = overed;
        }
    },

    drag: function(event){
        this.parent(event);
        if (this.options.checkDroppables && this.droppables.length) this.checkDroppables();
    },

    stop: function(event){
        this.checkDroppables();
        this.fireEvent('drop', [this.element, this.overed, event]);
        this.overed = null;
        return this.parent(event);
    }

});

Element.implement({

    makeDraggable: function(options){
        var drag = new Drag.Move(this, options);
        this.store('dragger', drag);
        return drag;
    }

});


/*
---

script: Request.Queue.js

description: Controls several instances of Request and its variants to run only one request at a time.

license: MIT-style license

authors:
- Aaron Newton

requires:
- core:1.2.4/Element
- core:1.2.4/Request
- /Log

provides: [Request.Queue]

...
*/

Request.Queue = new Class({

    Implements: [Options, Events],

    Binds: ['attach', 'request', 'complete', 'cancel', 'success', 'failure', 'exception'],

    options: {/*
        onRequest: $empty(argsPassedToOnRequest),
        onSuccess: $empty(argsPassedToOnSuccess),
        onComplete: $empty(argsPassedToOnComplete),
        onCancel: $empty(argsPassedToOnCancel),
        onException: $empty(argsPassedToOnException),
        onFailure: $empty(argsPassedToOnFailure),
        onEnd: $empty,
        */
        stopOnFailure: true,
        autoAdvance: true,
        concurrent: 1,
        requests: {}
    },

    initialize: function(options){
        if(options){
            var requests = options.requests;
            delete options.requests;    
        }
        this.setOptions(options);
        this.requests = new Hash;
        this.queue = [];
        this.reqBinders = {};
        
        if(requests) this.addRequests(requests);
    },

    addRequest: function(name, request){
        this.requests.set(name, request);
        this.attach(name, request);
        return this;
    },

    addRequests: function(obj){
        $each(obj, function(req, name){
            this.addRequest(name, req);
        }, this);
        return this;
    },

    getName: function(req){
        return this.requests.keyOf(req);
    },

    attach: function(name, req){
        if (req._groupSend) return this;
        ['request', 'complete', 'cancel', 'success', 'failure', 'exception'].each(function(evt){
            if(!this.reqBinders[name]) this.reqBinders[name] = {};
            this.reqBinders[name][evt] = function(){
                this['on' + evt.capitalize()].apply(this, [name, req].extend(arguments));
            }.bind(this);
            req.addEvent(evt, this.reqBinders[name][evt]);
        }, this);
        req._groupSend = req.send;
        req.send = function(options){
            this.send(name, options);
            return req;
        }.bind(this);
        return this;
    },

    removeRequest: function(req){
        var name = $type(req) == 'object' ? this.getName(req) : req;
        if (!name && $type(name) != 'string') return this;
        req = this.requests.get(name);
        if (!req) return this;
        ['request', 'complete', 'cancel', 'success', 'failure', 'exception'].each(function(evt){
            req.removeEvent(evt, this.reqBinders[name][evt]);
        }, this);
        req.send = req._groupSend;
        delete req._groupSend;
        return this;
    },

    getRunning: function(){
        return this.requests.filter(function(r){
            return r.running;
        });
    },

    isRunning: function(){
        return !!(this.getRunning().getKeys().length);
    },

    send: function(name, options){
        var q = function(){
            this.requests.get(name)._groupSend(options);
            this.queue.erase(q);
        }.bind(this);
        q.name = name;
        if (this.getRunning().getKeys().length >= this.options.concurrent || (this.error && this.options.stopOnFailure)) this.queue.push(q);
        else q();
        return this;
    },

    hasNext: function(name){
        return (!name) ? !!this.queue.length : !!this.queue.filter(function(q){ return q.name == name; }).length;
    },

    resume: function(){
        this.error = false;
        (this.options.concurrent - this.getRunning().getKeys().length).times(this.runNext, this);
        return this;
    },

    runNext: function(name){
        if (!this.queue.length) return this;
        if (!name){
            this.queue[0]();
        } else {
            var found;
            this.queue.each(function(q){
                if (!found && q.name == name){
                    found = true;
                    q();
                }
            });
        }
        return this;
    },

    runAll: function() {
        this.queue.each(function(q) {
            q();
        });
        return this;
    },

    clear: function(name){
        if (!name){
            this.queue.empty();
        } else {
            this.queue = this.queue.map(function(q){
                if (q.name != name) return q;
                else return false;
            }).filter(function(q){ return q; });
        }
        return this;
    },

    cancel: function(name){
        this.requests.get(name).cancel();
        return this;
    },

    onRequest: function(){
        this.fireEvent('request', arguments);
    },

    onComplete: function(){
        this.fireEvent('complete', arguments);
        if (!this.queue.length) this.fireEvent('end');
    },

    onCancel: function(){
        if (this.options.autoAdvance && !this.error) this.runNext();
        this.fireEvent('cancel', arguments);
    },

    onSuccess: function(){
        if (this.options.autoAdvance && !this.error) this.runNext();
        this.fireEvent('success', arguments);
    },

    onFailure: function(){
        this.error = true;
        if (!this.options.stopOnFailure && this.options.autoAdvance) this.runNext();
        this.fireEvent('failure', arguments);
    },

    onException: function(){
        this.error = true;
        if (!this.options.stopOnFailure && this.options.autoAdvance) this.runNext();
        this.fireEvent('exception', arguments);
    }

});


/*
---

script: Assets.js

description: Provides methods to dynamically load JavaScript, CSS, and Image files into the document.

license: MIT-style license

authors:
- Valerio Proietti

requires:
- core:1.2.4/Element.Event
- /MooTools.More

provides: [Assets]

...
*/

var Asset = {

    javascript: function(source, properties){
        properties = $extend({
            onload: $empty,
            document: document,
            check: $lambda(true)
        }, properties);

        var script = new Element('script', {src: source, type: 'text/javascript'});

        var load = properties.onload.bind(script), 
            check = properties.check, 
            doc = properties.document;
        delete properties.onload;
        delete properties.check;
        delete properties.document;

        script.addEvents({
            load: load,
            readystatechange: function(){
                if (['loaded', 'complete'].contains(this.readyState)) load();
            }
        }).set(properties);

        if (Browser.Engine.webkit419) var checker = (function(){
            if (!$try(check)) return;
            $clear(checker);
            load();
        }).periodical(50);

        return script.inject(doc.head);
    },

    css: function(source, properties){
        return new Element('link', $merge({
            rel: 'stylesheet',
            media: 'screen',
            type: 'text/css',
            href: source
        }, properties)).inject(document.head);
    },

    image: function(source, properties){
        properties = $merge({
            onload: $empty,
            onabort: $empty,
            onerror: $empty
        }, properties);
        var image = new Image();
        var element = document.id(image) || new Element('img');
        ['load', 'abort', 'error'].each(function(name){
            var type = 'on' + name;
            var event = properties[type];
            delete properties[type];
            image[type] = function(){
                if (!image) return;
                if (!element.parentNode){
                    element.width = image.width;
                    element.height = image.height;
                }
                image = image.onload = image.onabort = image.onerror = null;
                event.delay(1, element, element);
                element.fireEvent(name, element, 1);
            };
        });
        image.src = element.src = source;
        if (image && image.complete) image.onload.delay(1);
        return element.set(properties);
    },

    images: function(sources, options){
        options = $merge({
            onComplete: $empty,
            onProgress: $empty,
            onError: $empty,
            properties: {}
        }, options);
        sources = $splat(sources);
        var images = [];
        var counter = 0;
        return new Elements(sources.map(function(source){
            return Asset.image(source, $extend(options.properties, {
                onload: function(){
                    options.onProgress.call(this, counter, sources.indexOf(source));
                    counter++;
                    if (counter == sources.length) options.onComplete();
                },
                onerror: function(){
                    options.onError.call(this, counter, sources.indexOf(source));
                    counter++;
                    if (counter == sources.length) options.onComplete();
                }
            }));
        }));
    }

};

/*
---

script: Group.js

description: Class for monitoring collections of events

license: MIT-style license

authors:
- Valerio Proietti

requires:
- core:1.2.4/Events
- /MooTools.More

provides: [Group]

...
*/

var Group = new Class({

    initialize: function(){
        this.instances = Array.flatten(arguments);
        this.events = {};
        this.checker = {};
    },

    addEvent: function(type, fn){
        this.checker[type] = this.checker[type] || {};
        this.events[type] = this.events[type] || [];
        if (this.events[type].contains(fn)) return false;
        else this.events[type].push(fn);
        this.instances.each(function(instance, i){
            instance.addEvent(type, this.check.bind(this, [type, instance, i]));
        }, this);
        return this;
    },

    check: function(type, instance, i){
        this.checker[type][i] = true;
        var every = this.instances.every(function(current, j){
            return this.checker[type][j] || false;
        }, this);
        if (!every) return;
        this.checker[type] = {};
        this.events[type].each(function(event){
            event.call(this, this.instances, instance);
        }, this);
    }

});


/*
---

script: IframeShim.js

description: Defines IframeShim, a class for obscuring select lists and flash objects in IE.

license: MIT-style license

authors:
- Aaron Newton

requires:
- core:1.2.4/Element.Event
- core:1.2.4/Element.Style
- core:1.2.4/Options Events
- /Element.Position
- /Class.Occlude

provides: [IframeShim]

...
*/

var IframeShim = new Class({

    Implements: [Options, Events, Class.Occlude],

    options: {
        className: 'iframeShim',
        src: 'javascript:false;document.write("");',
        display: false,
        zIndex: null,
        margin: 0,
        offset: {x: 0, y: 0},
        browsers: (Browser.Engine.trident4 || (Browser.Engine.gecko && !Browser.Engine.gecko19 && Browser.Platform.mac))
    },

    property: 'IframeShim',

    initialize: function(element, options){
        this.element = document.id(element);
        if (this.occlude()) return this.occluded;
        this.setOptions(options);
        this.makeShim();
        return this;
    },

    makeShim: function(){
        if(this.options.browsers){
            var zIndex = this.element.getStyle('zIndex').toInt();

            if (!zIndex){
                zIndex = 1;
                var pos = this.element.getStyle('position');
                if (pos == 'static' || !pos) this.element.setStyle('position', 'relative');
                this.element.setStyle('zIndex', zIndex);
            }
            zIndex = ($chk(this.options.zIndex) && zIndex > this.options.zIndex) ? this.options.zIndex : zIndex - 1;
            if (zIndex < 0) zIndex = 1;
            this.shim = new Element('iframe', {
                src: this.options.src,
                scrolling: 'no',
                frameborder: 0,
                styles: {
                    zIndex: zIndex,
                    position: 'absolute',
                    border: 'none',
                    filter: 'progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=0)'
                },
                'class': this.options.className
            }).store('IframeShim', this);
            var inject = (function(){
                this.shim.inject(this.element, 'after');
                this[this.options.display ? 'show' : 'hide']();
                this.fireEvent('inject');
            }).bind(this);
            if (IframeShim.ready) window.addEvent('load', inject);
            else inject();
        } else {
            this.position = this.hide = this.show = this.dispose = $lambda(this);
        }
    },

    position: function(){
        if (!IframeShim.ready || !this.shim) return this;
        var size = this.element.measure(function(){ 
            return this.getSize(); 
        });
        if (this.options.margin != undefined){
            size.x = size.x - (this.options.margin * 2);
            size.y = size.y - (this.options.margin * 2);
            this.options.offset.x += this.options.margin;
            this.options.offset.y += this.options.margin;
        }
        this.shim.set({width: size.x, height: size.y}).position({
            relativeTo: this.element,
            offset: this.options.offset
        });
        return this;
    },

    hide: function(){
        if (this.shim) this.shim.setStyle('display', 'none');
        return this;
    },

    show: function(){
        if (this.shim) this.shim.setStyle('display', 'block');
        return this.position();
    },

    dispose: function(){
        if (this.shim) this.shim.dispose();
        return this;
    },

    destroy: function(){
        if (this.shim) this.shim.destroy();
        return this;
    }

});

window.addEvent('load', function(){
    IframeShim.ready = true;
});

/*
---

script: Mask.js

description: Creates a mask element to cover another.

license: MIT-style license

authors:
- Aaron Newton

requires:
- core:1.2.4/Options
- core:1.2.4/Events
- core:1.2.4/Element.Event
- /Class.Binds
- /Element.Position
- /IframeShim

provides: [Mask]

...
*/

var Mask = new Class({

    Implements: [Options, Events],

    Binds: ['resize'],

    options: {
        // onShow: $empty,
        // onHide: $empty,
        // onDestroy: $empty,
        // onClick: $empty,
        //inject: {
        //  where: 'after',
        //  target: null,
        //},
        // hideOnClick: false,
        // id: null,
        // destroyOnHide: false,
        style: {},
        'class': 'mask',
        maskMargins: false,
        useIframeShim: true
    },

    initialize: function(target, options){
        this.target = document.id(target) || document.body;
        this.target.store('mask', this);
        this.setOptions(options);
        this.render();
        this.inject();
    },
    
    render: function() {
        this.element = new Element('div', {
            'class': this.options['class'],
            id: this.options.id || 'mask-' + $time(),
            styles: $merge(this.options.style, {
                display: 'none'
            }),
            events: {
                click: function(){
                    this.fireEvent('click');
                    if (this.options.hideOnClick) this.hide();
                }.bind(this)
            }
        });
        this.hidden = true;
    },

    toElement: function(){
        return this.element;
    },

    inject: function(target, where){
        where = where || this.options.inject ? this.options.inject.where : '' || this.target == document.body ? 'inside' : 'after';
        target = target || this.options.inject ? this.options.inject.target : '' || this.target;
        this.element.inject(target, where);
        if (this.options.useIframeShim) {
            this.shim = new IframeShim(this.element);
            this.addEvents({
                show: this.shim.show.bind(this.shim),
                hide: this.shim.hide.bind(this.shim),
                destroy: this.shim.destroy.bind(this.shim)
            });
        }
    },

    position: function(){
        this.resize(this.options.width, this.options.height);
        this.element.position({
            relativeTo: this.target,
            position: 'topLeft',
            ignoreMargins: !this.options.maskMargins,
            ignoreScroll: this.target == document.body
        });
        return this;
    },

    resize: function(x, y){
        var opt = {
            styles: ['padding', 'border']
        };
        if (this.options.maskMargins) opt.styles.push('margin');
        var dim = this.target.getComputedSize(opt);
        if (this.target == document.body) {
            var win = window.getSize();
            if (dim.totalHeight < win.y) dim.totalHeight = win.y;
            if (dim.totalWidth < win.x) dim.totalWidth = win.x;
        }
        this.element.setStyles({
            width: $pick(x, dim.totalWidth, dim.x),
            height: $pick(y, dim.totalHeight, dim.y)
        });
        return this;
    },

    show: function(){
        if (!this.hidden) return this;
        this.target.addEvent('resize', this.resize);
        if (this.target != document.body) document.id(document.body).addEvent('resize', this.resize);
        this.position();
        this.showMask.apply(this, arguments);
        return this;
    },

    showMask: function(){
        this.element.setStyle('display', 'block');
        this.hidden = false;
        this.fireEvent('show');
    },

    hide: function(){
        if (this.hidden) return this;
        this.target.removeEvent('resize', this.resize);
        this.hideMask.apply(this, arguments);
        if (this.options.destroyOnHide) return this.destroy();
        return this;
    },

    hideMask: function(){
        this.element.setStyle('display', 'none');
        this.hidden = true;
        this.fireEvent('hide');
    },

    toggle: function(){
        this[this.hidden ? 'show' : 'hide']();
    },

    destroy: function(){
        this.hide();
        this.element.destroy();
        this.fireEvent('destroy');
        this.target.eliminate('mask');
    }

});

Element.Properties.mask = {

    set: function(options){
        var mask = this.retrieve('mask');
        return this.eliminate('mask').store('mask:options', options);
    },

    get: function(options){
        if (options || !this.retrieve('mask')){
            if (this.retrieve('mask')) this.retrieve('mask').destroy();
            if (options || !this.retrieve('mask:options')) this.set('mask', options);
            this.store('mask', new Mask(this, this.retrieve('mask:options')));
        }
        return this.retrieve('mask');
    }

};

Element.implement({

    mask: function(options){
        this.get('mask', options).show();
        return this;
    },

    unmask: function(){
        this.get('mask').hide();
        return this;
    }

});

/*
---

script: Tips.js

description: Class for creating nice tips that follow the mouse cursor when hovering an element.

license: MIT-style license

authors:
- Valerio Proietti
- Christoph Pojer

requires:
- core:1.2.4/Options
- core:1.2.4/Events
- core:1.2.4/Element.Event
- core:1.2.4/Element.Style
- core:1.2.4/Element.Dimensions
- /MooTools.More

provides: [Tips]

...
*/

(function(){

var read = function(option, element){
    return (option) ? ($type(option) == 'function' ? option(element) : element.get(option)) : '';
};

this.Tips = new Class({

    Implements: [Events, Options],

    options: {
        /*
        onAttach: $empty(element),
        onDetach: $empty(element),
        */
        onShow: function(){
            this.tip.setStyle('display', 'block');
        },
        onHide: function(){
            this.tip.setStyle('display', 'none');
        },
        title: 'title',
        text: function(element){
            return element.get('rel') || element.get('href');
        },
        showDelay: 100,
        hideDelay: 100,
        className: 'tip-wrap',
        offset: {x: 16, y: 16},
        fixed: false
    },

    initialize: function(){
        var params = Array.link(arguments, {options: Object.type, elements: $defined});
        this.setOptions(params.options);
        document.id(this);
        
        if (params.elements) this.attach(params.elements);
    },

    toElement: function(){
        if (this.tip) return this.tip;
        
        this.container = new Element('div', {'class': 'tip'});
        return this.tip = new Element('div', {
            'class': this.options.className,
            styles: {
                position: 'absolute',
                top: 0,
                left: 0
            }
        }).adopt(
            new Element('div', {'class': 'tip-top'}),
            this.container,
            new Element('div', {'class': 'tip-bottom'})
        ).inject(document.body);
    },

    attach: function(elements){
        $$(elements).each(function(element){
            var title = read(this.options.title, element),
                text = read(this.options.text, element);
            
            element.erase('title').store('tip:native', title).retrieve('tip:title', title);
            element.retrieve('tip:text', text);
            this.fireEvent('attach', [element]);
            
            var events = ['enter', 'leave'];
            if (!this.options.fixed) events.push('move');
            
            events.each(function(value){
                var event = element.retrieve('tip:' + value);
                if (!event) event = this['element' + value.capitalize()].bindWithEvent(this, element);
                
                element.store('tip:' + value, event).addEvent('mouse' + value, event);
            }, this);
        }, this);
        
        return this;
    },

    detach: function(elements){
        $$(elements).each(function(element){
            ['enter', 'leave', 'move'].each(function(value){
                element.removeEvent('mouse' + value, element.retrieve('tip:' + value)).eliminate('tip:' + value);
            });
            
            this.fireEvent('detach', [element]);
            
            if (this.options.title == 'title'){ // This is necessary to check if we can revert the title
                var original = element.retrieve('tip:native');
                if (original) element.set('title', original);
            }
        }, this);
        
        return this;
    },

    elementEnter: function(event, element){
        this.container.empty();
        
        ['title', 'text'].each(function(value){
            var content = element.retrieve('tip:' + value);
            if (content) this.fill(new Element('div', {'class': 'tip-' + value}).inject(this.container), content);
        }, this);
        
        $clear(this.timer);
        this.timer = this.show.delay(this.options.showDelay, this, element);
        this.position((this.options.fixed) ? {page: element.getPosition()} : event);
    },

    elementLeave: function(event, element){
        $clear(this.timer);
        this.timer = this.hide.delay(this.options.hideDelay, this, element);
        this.fireForParent(event, element);
    },

    fireForParent: function(event, element){
        if (!element) return;
        parentNode = element.getParent();
        if (parentNode == document.body) return;
        if (parentNode.retrieve('tip:enter')) parentNode.fireEvent('mouseenter', event);
        else this.fireForParent(parentNode, event);
    },

    elementMove: function(event, element){
        this.position(event);
    },

    position: function(event){
        var size = window.getSize(), scroll = window.getScroll(),
            tip = {x: this.tip.offsetWidth, y: this.tip.offsetHeight},
            props = {x: 'left', y: 'top'},
            obj = {};
        
        for (var z in props){
            obj[props[z]] = event.page[z] + this.options.offset[z];
            if ((obj[props[z]] + tip[z] - scroll[z]) > size[z]) obj[props[z]] = event.page[z] - this.options.offset[z] - tip[z];
        }
        
        this.tip.setStyles(obj);
    },

    fill: function(element, contents){
        if(typeof contents == 'string') element.set('html', contents);
        else element.adopt(contents);
    },

    show: function(element){
        this.fireEvent('show', [this.tip, element]);
    },

    hide: function(element){
        this.fireEvent('hide', [this.tip, element]);
    }

});

})();

/*
---

script: Spinner.js

description: Adds a semi-transparent overlay over a dom element with a spinnin ajax icon.

license: MIT-style license

authors:
- Aaron Newton

requires:
- core:1.2.4/Fx.Tween
- /Class.refactor
- /Mask

provides: [Spinner]

...
*/

var Spinner = new Class({

    Extends: Mask,

    options: {
        /*message: false,*/
        'class':'spinner',
        containerPosition: {},
        content: {
            'class':'spinner-content'
        },
        messageContainer: {
            'class':'spinner-msg'
        },
        img: {
            'class':'spinner-img'
        },
        fxOptions: {
            link: 'chain'
        }
    },

    initialize: function(){
        this.parent.apply(this, arguments);
        this.target.store('spinner', this);

        //add this to events for when noFx is true; parent methods handle hide/show
        var deactivate = function(){ this.active = false; }.bind(this);
        this.addEvents({
            hide: deactivate,
            show: deactivate
        });
    },

    render: function(){
        this.parent();
        this.element.set('id', this.options.id || 'spinner-'+$time());
        this.content = document.id(this.options.content) || new Element('div', this.options.content);
        this.content.inject(this.element);
        if (this.options.message) {
            this.msg = document.id(this.options.message) || new Element('p', this.options.messageContainer).appendText(this.options.message);
            this.msg.inject(this.content);
        }
        if (this.options.img) {
            this.img = document.id(this.options.img) || new Element('div', this.options.img);
            this.img.inject(this.content);
        }
        this.element.set('tween', this.options.fxOptions);
    },

    show: function(noFx){
        if (this.active) return this.chain(this.show.bind(this));
        if (!this.hidden) {
            this.callChain.delay(20, this);
            return this;
        }
        this.active = true;
        return this.parent(noFx);
    },

    showMask: function(noFx){
        var pos = function(){
            this.content.position($merge({
                relativeTo: this.element
            }, this.options.containerPosition));
        }.bind(this);
        if (noFx) {
            this.parent();
            pos();
        } else {
            this.element.setStyles({
                display: 'block',
                opacity: 0
            }).tween('opacity', this.options.style.opacity || 0.9);
            pos();
            this.hidden = false;
            this.fireEvent('show');
            this.callChain();
        }
    },

    hide: function(noFx){
        if (this.active) return this.chain(this.hide.bind(this));
        if (this.hidden) {
            this.callChain.delay(20, this);
            return this;
        }
        this.active = true;
        return this.parent(noFx);
    },

    hideMask: function(noFx){
        if (noFx) return this.parent();
        this.element.tween('opacity', 0).get('tween').chain(function(){
            this.element.setStyle('display', 'none');
            this.hidden = true;
            this.fireEvent('hide');
            this.callChain();
        }.bind(this));
    },

    destroy: function(){
        this.content.destroy();
        this.parent();
        this.target.eliminate('spinner');
    }

});

Spinner.implement(new Chain);

if (window.Request) {
    Request = Class.refactor(Request, {
        
        options: {
            useSpinner: false,
            spinnerOptions: {},
            spinnerTarget: false
        },
        
        initialize: function(options){
            this._send = this.send;
            this.send = function(options){
                if (this.spinner) this.spinner.chain(this._send.bind(this, options)).show();
                else this._send(options);
                return this;
            };
            this.previous(options);
            var update = document.id(this.options.spinnerTarget) || document.id(this.options.update);
            if (this.options.useSpinner && update) {
                this.spinner = update.get('spinner', this.options.spinnerOptions);
                ['onComplete', 'onException', 'onCancel'].each(function(event){
                    this.addEvent(event, this.spinner.hide.bind(this.spinner));
                }, this);
            }
        },
        
        getSpinner: function(){
            return this.spinner;
        }
        
    });
}

Element.Properties.spinner = {

    set: function(options){
        var spinner = this.retrieve('spinner');
        return this.eliminate('spinner').store('spinner:options', options);
    },

    get: function(options){
        if (options || !this.retrieve('spinner')){
            if (this.retrieve('spinner')) this.retrieve('spinner').destroy();
            if (options || !this.retrieve('spinner:options')) this.set('spinner', options);
            new Spinner(this, this.retrieve('spinner:options'));
        }
        return this.retrieve('spinner');
    }

};

Element.implement({

    spin: function(options){
        this.get('spinner', options).show();
        return this;
    },

    unspin: function(){
        var opt = Array.link(arguments, {options: Object.type, callback: Function.type});
        this.get('spinner', opt.options).hide(opt.callback);
        return this;
    }

});

/*
---

script: Date.English.US.js

description: Date messages for US English.

license: MIT-style license

authors:
- Aaron Newton

requires:
- /Lang
- /Date

provides: [Date.English.US]

...
*/

MooTools.lang.set('en-US', 'Date', {

    months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    //culture's date order: MM/DD/YYYY
    dateOrder: ['month', 'date', 'year'],
    shortDate: '%m/%d/%Y',
    shortTime: '%I:%M%p',
    AM: 'AM',
    PM: 'PM',

    /* Date.Extras */
    ordinal: function(dayOfMonth){
        //1st, 2nd, 3rd, etc.
        return (dayOfMonth > 3 && dayOfMonth < 21) ? 'th' : ['th', 'st', 'nd', 'rd', 'th'][Math.min(dayOfMonth % 10, 4)];
    },

    lessThanMinuteAgo: 'less than a minute ago',
    minuteAgo: 'about a minute ago',
    minutesAgo: '{delta} minutes ago',
    hourAgo: 'about an hour ago',
    hoursAgo: 'about {delta} hours ago',
    dayAgo: '1 day ago',
    daysAgo: '{delta} days ago',
    weekAgo: '1 week ago',
    weeksAgo: '{delta} weeks ago',
    monthAgo: '1 month ago',
    monthsAgo: '{delta} months ago',
    yearAgo: '1 year ago',
    yearsAgo: '{delta} years ago',
    lessThanMinuteUntil: 'less than a minute from now',
    minuteUntil: 'about a minute from now',
    minutesUntil: '{delta} minutes from now',
    hourUntil: 'about an hour from now',
    hoursUntil: 'about {delta} hours from now',
    dayUntil: '1 day from now',
    daysUntil: '{delta} days from now',
    weekUntil: '1 week from now',
    weeksUntil: '{delta} weeks from now',
    monthUntil: '1 month from now',
    monthsUntil: '{delta} months from now',
    yearUntil: '1 year from now',
    yearsUntil: '{delta} years from now'

});
